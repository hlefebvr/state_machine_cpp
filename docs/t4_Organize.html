<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>state_machine_cpp: Organize your code!</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">state_machine_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('t4_Organize.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Organize your code! </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Hi there! I hope you enjoyed the first three tutorials! Now is time to give you some guidelines on how to structure your code when using <a class="el" href="namespacestate__machine__cpp.html">state_machine_cpp</a>. Let's dive in with our list of guidelines and good practise!</p>
<h1><a class="anchor" id="autotoc_md21"></a>
#1 Define your states as static attributes of your builder</h1>
<p>As a first guideline, it is highly suggested defining everything which is related to your algorithm inside your algorithm builder. This applies for states, in particular. Thus, rather than having the following code: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> State::Id INITIAL_STATE(<span class="stringliteral">&quot;ExampleAlgorithm::INITIAL_STATE&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ExampleAlgorithm final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        states.create(INITIAL_STATE);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>You should prefer having the following: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ExampleAlgorithm final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id INITIAL_STATE;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        states.create(INITIAL_STATE);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> State::Id ExampleAlgorithm::INITIAL_STATE = State::Id(<span class="stringliteral">&quot;ExampleAlgorithm::INITIAL_STATE&quot;</span>);</div>
</div><!-- fragment --><p>Why ? Simply because it is more natural to relate to the INITIAL_STATE of the ExampleAlgorithm algorithm by calling <code>ExampleAlgorithm::INITIAL_STATE</code> rather than <code>INITIAL_STATE</code>. Moreover, you therefore prevent other developers to name their state C++ variable <code>INITIAL_STATE</code>. Finally, this also allows for auto-detection of states as described in point #7 of this page.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
#2 Use namespaces for your State::Id</h1>
<p>Using namespaces for State::Id names is also a good idea. Why? Imagine having two algorithms having an <code>INITIAL_STATE</code> whose name are defined as <code>INITIAL_STATE</code> and `<code>INITIAL_STATE</code> as shown in the following code: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id INITIAL_STATE; </div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>B final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id INITIAL_STATE;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> State::Id A::INITIAL_STATE = State::Id(<span class="stringliteral">&quot;INITIAL_STATE&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> State::Id B::INITIAL_STATE = State::Id(<span class="stringliteral">&quot;INITIAL_STATE&quot;</span>);</div>
</div><!-- fragment --><p>If this situation happens, then other developers cannot directly import their algorithm from both <code>A</code> and <code>B</code>. Rather, they need to use two different layers. Why? Because when adding <code>A::INITIAL_STATE</code> and <code>B::INITIAL_STATE</code> ont the same layer, an exception will be throw saying that a state is being added twice. Indeed, they both have the same name! It would be possible to import from both algorithms by doing the following: </p><div class="fragment"><div class="line"><span class="keyword">class </span>C final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        import&lt;A&gt;(states, transitions, layers);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> layer_id = layers.create();</div>
<div class="line">            import&lt;B&gt;(states, transitions, layers);        </div>
<div class="line">        layers.close();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>However, this code has a sort of useless complexity. Consider using namespaces for state names, i.e., having, </p><div class="fragment"><div class="line"><span class="keyword">const</span> State::Id A::INITIAL_STATE = State::Id(<span class="stringliteral">&quot;A::INITIAL_STATE&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> State::Id B::INITIAL_STATE = State::Id(<span class="stringliteral">&quot;B::INITIAL_STATE&quot;</span>);</div>
</div><!-- fragment --><p>And the previous code can be conceptually simplified as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>C final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        import&lt;A&gt;(states, transitions, layers);</div>
<div class="line">        import&lt;B&gt;(states, transitions, layers);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
#3 Define your transitions handlers as static methods</h1>
<p>In the same spirit as #1, you should also define your transitions handlers as static methods of your algorithm builder. Again, this is done for clarity and maintainability reasons. This also provides symbols to being overridden.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
#4 Define your attributes as nested class</h1>
<p>Defining your attributes as nested class, again, improves readability. For instance, think back again about* our <a class="el" href="classForLoop.html">ForLoop</a> algorithm. To make this algorithm work, we created a <code>ForLoopAttributes</code> class. Defining it inside the <a class="el" href="classForLoop.html">ForLoop</a> class allows us to use the more readable <code><a class="el" href="structForLoop_1_1Attributes.html">ForLoop::Attributes</a></code> expression! Moreover, our handlers can now embed the following code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> some_example_handler(Context&amp; context) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; attributes = context.get&lt;Attributes&gt;();</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>which is much more clear! Moreover, you end up with multiple imports which would result in codes like the following one: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> some_other_example_handler(Context&amp; context) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; a_attributes = context.get&lt;A::Attributes&gt;();</div>
<div class="line">    <span class="keyword">auto</span>&amp; b_attributes = context.get&lt;B::Attributes&gt;();</div>
<div class="line">    <span class="keyword">auto</span>&amp; c_attributes = context.get&lt;C::Attributes&gt;();</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This way of managing attributes is therefore generic!</p>
<p>Moreover, we encourage you to always define an <code>Attribute</code> nested class, even in cases where you are reusing an existing class! See the following: </p><div class="fragment"><div class="line"><span class="keyword">class </span>B final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> Attributes = A::Attributes;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(<span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>This simplifies and generalizes the approach to every algorithm.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
#5 Create final builders</h1>
<p>As a general guideline, importing algorithms should be done through the <code>Algorithm::Builder::import</code> template method. To ensure that, we recommend that every algorithm builder be declared as a <code>final</code> class.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
#6 Define a create_attributes static method</h1>
<p>Creating algorithm's context may become complex. See, for instance, the following code used to create our <a class="el" href="classDoubleLoop.html">DoubleLoop</a>'s context: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> attribute_tree = AttributeTree&lt;</div>
<div class="line">                        Layer&lt;ForLoopAttributes&gt;,  </div>
<div class="line">                        Layer&lt;ForLoopAttributes&gt;</div>
<div class="line">                    &gt;(</div>
<div class="line">                        <span class="keyword">new</span> Layer(<span class="keyword">new</span> ForLoopAttributes(3)),</div>
<div class="line">                        <span class="keyword">new</span> Layer(<span class="keyword">new</span> ForLoopAttributes(5))</div>
<div class="line">                    );</div>
<div class="line"><span class="keyword">auto</span> context = Context(attribute_tree);</div>
</div><!-- fragment --><p>To ease the creation of algorithmic contexts, we recommend to developers to define a static method called <code>create_attributes</code> returning a pointer to the according AttributeTree&lt;...&gt;. See how it can be create: </p><div class="fragment"><div class="line">AttributeTree&lt;Layer&lt;ForLoop::Attributes&gt;, Layer&lt;ForLoop::Attributes&gt;&gt;*</div>
<div class="line">    create_attributes(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m) {</div>
<div class="line">    </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> AttributeTree&lt;Layer&lt;ForLoop::Attributes&gt;, Layer&lt;ForLoop::Attributes&gt;&gt;(</div>
<div class="line">                    <span class="keyword">new</span> Layer(<span class="keyword">new</span> <a class="code" href="structForLoop_1_1Attributes.html">ForLoop::Attributes</a>(n)),</div>
<div class="line">                    <span class="keyword">new</span> Layer(<span class="keyword">new</span> <a class="code" href="structForLoop_1_1Attributes.html">ForLoop::Attributes</a>(m))</div>
<div class="line">                );</div>
<div class="line">        </div>
<div class="line">    }</div>
</div><!-- fragment --><p>The recommendation is as follows: declare a static method returning an <code>AutoContext</code> inside your algorithm builder. See, for instance, the following piece of code: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classDoubleLoop.html">DoubleLoop</a> final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classDoubleLoop.html#afd8d00de36a248a79716fb41cd05fd99">build</a>(States &amp;states, Transitions &amp;transitions, Layers &amp;layers)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> AttributeTree&lt;Layer&lt;ForLoop::Attributes&gt;, Layer&lt;ForLoop::Attributes&gt;&gt;*</div>
<div class="line">    <a class="code" href="classDoubleLoop.html#ac85c08b584ad76680ab7fbfe896ea3be">create_attributes</a>(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> AttributeTree&lt;Layer&lt;ForLoop::Attributes&gt;, Layer&lt;ForLoop::Attributes&gt;&gt;(</div>
<div class="line">                    <span class="keyword">new</span> Layer(<span class="keyword">new</span> <a class="code" href="structForLoop_1_1Attributes.html">ForLoop::Attributes</a>(n)),</div>
<div class="line">                    <span class="keyword">new</span> Layer(<span class="keyword">new</span> <a class="code" href="structForLoop_1_1Attributes.html">ForLoop::Attributes</a>(m))</div>
<div class="line">                );</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This allows us to run our algorithm as follows: </p><div class="fragment"><div class="line">Algorithm::Instance algorithm;</div>
<div class="line">Algorithm::build&lt;DoubleLoop&gt;(algorithm);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> context = Context::create&lt;DoubleLoop&gt;(3, 5);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a14b70d0b3e7c803e462319b0be2f1393">Algorithm::run</a>(algorithm, context);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md27"></a>
#7 Define an INITIAL_STATE and a FINAL_STATE</h1>
<p>You probably noticed from our previous tutorial the necessity of the following lines before running an algorithm: </p><div class="fragment"><div class="line">algorithm.set_initial_state(MY_INITIAL_STATE);</div>
<div class="line">algorithm.set_final_state(MY_FINAL_STATE);</div>
</div><!-- fragment --><p>Note that these lines can be made optional by defining a static attribute inside your algorithm builder with the C++ symbol names <code>INITIAL_STATE</code> and <code>FINAL_STATE</code> as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ExampleAlgorithm final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id INITIAL_STATE;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id FINAL_STATE;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        states.create(INITIAL_STATE);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> State::Id ExampleAlgorithm::INITIAL_STATE = State::Id(<span class="stringliteral">&quot;ExampleAlgorithm::INITIAL_STATE&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> State::Id ExampleAlgorithm::FINAL_STATE = State::Id(<span class="stringliteral">&quot;ExampleAlgorithm::FINAL_STATE&quot;</span>);</div>
</div><!-- fragment --><p>By doing so, <a class="el" href="namespacestate__machine__cpp.html">state_machine_cpp</a> will automatically set the initial state and final state for you! You, therefore, won't have to define your initial and final state manually each time you want to run your algorithm. For genericity reasons, we advise doing so for every algorithm you create.</p>
<p>Note that when algorithm do not define their own <code>INITIAL_STATE</code> because they use another algorithm's state as initial state, it is still possible to apply this guideline as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>B final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id&amp; INITIAL_STATE;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> State::Id&amp; FINAL_STATE;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> State::Id&amp; B::INITIAL_STATE = A::INITIAL_STATE;</div>
<div class="line"><span class="keyword">const</span> State::Id&amp; B::FINAL_STATE = A::FINAL_STATE;</div>
</div><!-- fragment --><p>That's it for our guidelines! You know now how to organize a clean code using state_machine_cpp! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_html_a14b70d0b3e7c803e462319b0be2f1393"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm.html#a14b70d0b3e7c803e462319b0be2f1393">state_machine_cpp::Algorithm::run</a></div><div class="ttdeci">void run(const Algorithm::Instance &amp;t_instance, Context &amp;t_context)</div></div>
<div class="ttc" id="aclassDoubleLoop_html_afd8d00de36a248a79716fb41cd05fd99"><div class="ttname"><a href="classDoubleLoop.html#afd8d00de36a248a79716fb41cd05fd99">DoubleLoop::build</a></div><div class="ttdeci">void build(States &amp;states, Transitions &amp;transitions, Layers &amp;layers) override</div><div class="ttdef"><b>Definition:</b> <a href="example__DoubleLoop__main_8cpp_source.html#l00020">example_DoubleLoop_main.cpp:20</a></div></div>
<div class="ttc" id="aclassDoubleLoop_html_ac85c08b584ad76680ab7fbfe896ea3be"><div class="ttname"><a href="classDoubleLoop.html#ac85c08b584ad76680ab7fbfe896ea3be">DoubleLoop::create_attributes</a></div><div class="ttdeci">static AttributeTree&lt; Layer&lt; ForLoop::Attributes &gt;, Layer&lt; ForLoop::Attributes &gt; &gt; * create_attributes(int n, int m)</div><div class="ttdef"><b>Definition:</b> <a href="example__DoubleLoop__main_8cpp_source.html#l00033">example_DoubleLoop_main.cpp:33</a></div></div>
<div class="ttc" id="astructForLoop_1_1Attributes_html"><div class="ttname"><a href="structForLoop_1_1Attributes.html">ForLoop::Attributes</a></div><div class="ttdef"><b>Definition:</b> <a href="example__ForLoop__main_8cpp_source.html#l00013">example_ForLoop_main.cpp:13</a></div></div>
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_html_a548ba4a6bcf678d2ad0618c99053e4a4"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm.html#a548ba4a6bcf678d2ad0618c99053e4a4">state_machine_cpp::Algorithm::build</a></div><div class="ttdeci">void build(Algorithm::Instance &amp;t_destination, Algorithm::Mode t_build_mode=Algorithm::Mode::Release)</div><div class="ttdef"><b>Definition:</b> <a href="build_8h_source.html#l00051">build.h:51</a></div></div>
<div class="ttc" id="aclassDoubleLoop_html"><div class="ttname"><a href="classDoubleLoop.html">DoubleLoop</a></div><div class="ttdef"><b>Definition:</b> <a href="example__DoubleLoop__main_8cpp_source.html#l00008">example_DoubleLoop_main.cpp:8</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Tutorial.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
