<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>state_machine_cpp: [Tutorial] DoubleLoop: The layer concept</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">state_machine_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_src_tutorials_3_DoubleLoop.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">[Tutorial] DoubleLoop: The layer concept </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Hey there! This tutorial introduces somehow advanced features of the <a class="el" href="namespacestate__machine__cpp.html">state_machine_cpp</a> library. Be sure to have checked out previous tutorials before reading this one. Otherwise, let's dive in!</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Introduction</h1>
<p>In this tutorial we will be creating a double for loop based on our ForLoop algorithm. Thus, our algorithm will use twice the same algorithm and use two different ForLoopAttributes to manage its internal state. The objective of this tutorial is therefore to use the ForLoop algorithm so as to get the following input: </p><div class="fragment"><div class="line">0, 0</div>
<div class="line">0, 1</div>
<div class="line">0, 2</div>
<div class="line">0, 3</div>
<div class="line">0, 4</div>
<div class="line">1, 0</div>
<div class="line">1, 1</div>
<div class="line">1, 2</div>
<div class="line">1, 3</div>
<div class="line">1, 4</div>
<div class="line">2, 0</div>
<div class="line">2, 1</div>
<div class="line">2, 2</div>
<div class="line">2, 3</div>
<div class="line">2, 4</div>
</div><!-- fragment --><p>The resulting algorithm will therefore be equivalent to the following C++ code. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ; i &lt; 3 ; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0 ; j &lt; 5 ; ++j) {</div>
<div class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's see how it's done!</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Inheriting twice</h1>
<p>We have seen, in the previous tutorial, how one algorithm could import all the states and transitions from another. Let's start by doing this once! </p><div class="fragment"><div class="line"><span class="keyword">class </span>DoubleLoop final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Up to there, nothing new. Visualizing our algorithm yields the expected followng result:</p>
<p><img src="https://raw.githubusercontent.com/hlefebvr/state_machine_cpp/main/src/images/my_algorithm_tx.png" alt="my_algorithm.png" class="inline"/></p>
<p>Now let's try to inherit twice algorithm ForLoop, as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">    inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">    inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">}</div>
</div><!-- fragment --><p>And let's build our algorithm!</p>
<p>Unfortunately, we were thrown with an exception saying "Cannot create twice the same state instance.". Indeed, inheritance does nothing but import all the states from an algorithm to the current one. The same is done for each transition. We therefore cannot inherit twice from the same algorithm as this would create, indeed, twice the same states. Moreover, both ForLoop (the first) and ForLoop (the secondly inherited) use the same kind of attributes. How would one know which attribute to consider when running the algorithm ? This situation is solved by the concept of layers.</p>
<p>So far, our algorithms were made out of only one layer since they were rather simple and always used different attribute classes. However, it is possible to create a new layer inside the algorithm so that two state of the same kind coexist within the same algorithm (but on different "levels", i.e., on different layers).</p>
<p>See rather the following code. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">    </div>
<div class="line">    inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">    </div>
<div class="line">    layers.create();</div>
<div class="line">        inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">    layers.close();</div>
<div class="line">    </div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, building this algorithm works! Let's visualize it so that it becomes clear what happened.</p>
<p><img src="https://raw.githubusercontent.com/hlefebvr/state_machine_cpp/main/src/images/my_algorithm_copied.png" alt="my_algorithm.png" class="inline"/></p>
<p>You can see that our ForLoop algorithm has been imported twice! Yet, it has been "instantiated" on two different layers: 0 and 1. Note that, at any time, it is possible to know the current layer by calling the <code>layers.current</code> method.</p>
<p>Now that we have copied our algorithm twice, let's insert it to obtain one single algorithmic flow!</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Playing with layers</h1>
<p>Inside the build function, every use of a State::Id, in fact, refers to the state with the corresponding State::Id associated to the current layer id. Thus, when calling, for instance, <code>states.create(INITIAL_STATE);</code>, we in fact created the state <code>INITIAL_STATE[0]</code>, i.e., <code>INITIAL_STATE</code> on layer 0. So far, we did not even mention it since it was not relevant to our case, here, it becomes crucial to understand it.</p>
<p>To be even more specific, observe the following piece of code (which is independent of the double-loop project). </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> State::Id MY_STATE(<span class="stringliteral">&quot;MY_STATE&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>LayerExample final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        </div>
<div class="line">        states.create(MY_STATE); <span class="comment">// creates MY_STATE[0]</span></div>
<div class="line">        </div>
<div class="line">        layers.create(); <span class="comment">// creates layer 1</span></div>
<div class="line">            states.create(MY_STATE); <span class="comment">// creates MY_STATE[1]</span></div>
<div class="line">        layers.close(); <span class="comment">// returns to layer 0</span></div>
<div class="line">        </div>
<div class="line">        states.remove(MY_STATE); <span class="comment">// removes MY_STATE[0]</span></div>
<div class="line">        </div>
<div class="line">        layers.use(1);</div>
<div class="line">            states.removes(MY_STATE); <span class="comment">// removes MY_STATE[1]</span></div>
<div class="line">        layers.close();</div>
<div class="line">        </div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Things should be more clear now. However, two important remarks should be made at this point.</p><ul>
<li>First, note that every time <code>layers.create</code> or <code>layers.use</code> is being called, a corresponding <code>layers.close</code> should be called. If this fails to be done then an exception will be thrown.</li>
<li>Then, <code>layers.create</code> in fact returns the id of the layer and it is better - in the sense of "more modular" to act upon layers using variables rather than explicit values. Why? Simply because your algorithm may further be inherited by another algorithm and that layer 1 may well be something else. Using a variable allows your code to be more general and context independent.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Routing between layers</h1>
<p>Back to our double for loop example! We now want to insert one algorithm inside the other. In other words, we want to override the transition from <code>LOOP_ITERATION[0]</code> to <code>INITIAL_STATE[1]</code> and to override the transition from <code>FINAL_STATE[1]</code> to <code>AFTER_LOOP_ITERATION[1]</code>.</p>
<p>This can be done as follows. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">    </div>
<div class="line">    inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = layers.create();</div>
<div class="line">        inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">    layers.close();</div>
<div class="line"> </div>
<div class="line">    transitions.override(LOOP_ITERATION, INITIAL_STATE[A]);</div>
<div class="line">    transitions.override(FINAL_STATE[A], AFTER_LOOP_ITERATION);</div>
<div class="line">    </div>
<div class="line">}</div>
</div><!-- fragment --><p>Visualizing the resulting algorithm, one obtains the following.</p>
<p><img src="https://raw.githubusercontent.com/hlefebvr/state_machine_cpp/main/src/images/my_algorithm_merged.png" alt="my_algorithm.png" class="inline"/></p>
<p>We therefore have successfully inserted our copied version of ForLoop inside another copied version of ForLoop.</p>
<p>To run our algorithm though, we need to define a new context called <code>LayredContext</code>. The following piece of code speaks for iteself. </p><div class="fragment"><div class="line">ForLoopAttributes for_loop_attributes_1(3);</div>
<div class="line">ForLoopAttributes for_loop_attributes_2(5);</div>
<div class="line">SimpleContext&lt;ForLoopAttributes&gt; context(for_loop_attributes_1);</div>
<div class="line">SimpleContext&lt;ForLoopAttributes&gt; context_2(for_loop_attributes_2);</div>
<div class="line">LayeredContext&lt;2&gt; layered_context(context, context_2);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacestate__machine__cpp_1_1Algorithm_1_1Impl.html#a7e72e2565b9da5dba77fae4f7ae5c00e">Algorithm::run</a>(algorithm, layered_context, INITIAL_STATE, FINAL_STATE);</div>
</div><!-- fragment --><p>Running our resulting algorithm outputs the following. </p><div class="fragment"><div class="line">0</div>
<div class="line">1</div>
<div class="line">2</div>
<div class="line">3</div>
<div class="line">4</div>
<div class="line">0</div>
<div class="line">1</div>
<div class="line">2</div>
<div class="line">3</div>
<div class="line">4</div>
<div class="line">0</div>
<div class="line">1</div>
<div class="line">2</div>
<div class="line">3</div>
<div class="line">4</div>
</div><!-- fragment --><p>We can see here that the algorithm does, indeed, perform a double for loop! However, the goal of this tutorial was to print <code>i, j</code> at each iteration, and not only <code>i</code> or <code>j</code>. In the following section, we will see how it is possible to access the attributes of another layer throughout the context object.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Accessing layered context</h1>
<p>In this last section, we will override the transition between <code>SHOW_COUNTER[A]</code> and <code>INCREMENT_COUNTER[A]</code> in order to print <code>i, j</code>. To do this, we need to access the context's attribute of a different layer than the one which triggered the transition. This can be done by using the <code>context.get_relative&lt;T&gt;</code> template function. This function takes an argument which is the offset from which to access the attributes. Thus, we have <code>context.get&lt;T&gt;()</code> which is equivalent to <code>context.get_relative&lt;T&gt;(0)</code>. And <code>context.get_relative&lt;T&gt;(-1)</code> which accesses the attribute of type <code>T</code> as used by the previous layer. See rather how we can write our new handler. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> show_double_counter(Context&amp; context) {</div>
<div class="line">    std::cout &lt;&lt; context.get_relative&lt;CounterAttributes&gt;(-1).iteration</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line">              &lt;&lt; context.get&lt;CounterAttributes&gt;().iteration</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, we are printing the iteration counter of the previous layer, then, print out the iteration counter of the current layer.</p>
<p>We can then override our transition as follows. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States &amp;states, Transitions &amp;transitions, Layers &amp;layers)<span class="keyword"> override </span>{</div>
<div class="line">    inherit&lt;Counter&gt;(states, transitions, layers);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = layers.create();</div>
<div class="line">        inherit&lt;Counter&gt;(states, transitions, layers);</div>
<div class="line">        </div>
<div class="line">        transitions.override(SHOW_COUNTER, INCREMENT_COUNTER, show_double_counter);</div>
<div class="line">        </div>
<div class="line">    layers.close();</div>
<div class="line"> </div>
<div class="line">    transitions.override(SHOW_COUNTER, INITIAL_STATE[A]);</div>
<div class="line">    transitions.override(FINAL_STATE[A], INCREMENT_COUNTER);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Running our algorithm now prints out the following result. </p><div class="fragment"><div class="line">0, 0</div>
<div class="line">0, 1</div>
<div class="line">0, 2</div>
<div class="line">0, 3</div>
<div class="line">0, 4</div>
<div class="line">1, 0</div>
<div class="line">1, 1</div>
<div class="line">1, 2</div>
<div class="line">1, 3</div>
<div class="line">1, 4</div>
<div class="line">2, 0</div>
<div class="line">2, 1</div>
<div class="line">2, 2</div>
<div class="line">2, 3</div>
<div class="line">2, 4</div>
</div><!-- fragment --><p>And voilà! We have successfully built an algorithm as the combination of the same algorithm with itself! As an exercise, try to implement a template algorithm <code>MultipleLoop&lt;unsigne int N&gt;</code> which creates an <code>N</code>-loop. Enjoy! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_html_ac1e565dffdf5bbfe13afb2c9988e409f"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">state_machine_cpp::Algorithm::build</a></div><div class="ttdeci">void build(Algorithm::Instance &amp;t_destination)</div><div class="ttdef"><b>Definition:</b> <a href="build_8h_source.html#l00019">build.h:19</a></div></div>
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_1_1Impl_html_a7e72e2565b9da5dba77fae4f7ae5c00e"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm_1_1Impl.html#a7e72e2565b9da5dba77fae4f7ae5c00e">state_machine_cpp::Algorithm::Impl::run</a></div><div class="ttdeci">void run(::state_machine_cpp::Context &amp;t_context, const ::state_machine_cpp::State::Id &amp;t_initial_state, const ::state_machine_cpp::State::Id &amp;t_final_state, const std::function&lt; State::Instance(const Algorithm::Instance &amp;t_instance, const State::Instance &amp;t_state, Context &amp;t_context)&gt; &amp;t_apply_transition)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
