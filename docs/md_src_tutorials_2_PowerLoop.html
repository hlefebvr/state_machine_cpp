<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>state_machine_cpp: [Tutorial] PowerLoop: Inheriting algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">state_machine_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_src_tutorials_2_PowerLoop.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">[Tutorial] PowerLoop: Inheriting algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Hey! This tutorial is built upon the <a class="el" href="1__ForLoop_8md.html">ForLoop tutorial</a>, if you haven't followed it yet, be sure to check it out first! Otherwise, let's dive in!</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Introduction</h1>
<p>In this tutorial, we will be learning how algorithms can be inherited so as to modify their behavior. The goal here is to use the ForLoop algorithm introduced in the previous tutorial but to modify the action which is executed at each loop iteration. Indeed, we want, at each iteration, to print out powers of the current iteration. For instance, if the power is set to 2 and the max_iteration is set to 3, we should obtain the following output: </p><div class="fragment"><div class="line">0 <span class="comment">// 0^2</span></div>
<div class="line">1 <span class="comment">// 1^2</span></div>
<div class="line">4 <span class="comment">// 2^2</span></div>
</div><!-- fragment --><p>Let's first create an empty algorithm in the next section!</p>
<h1><a class="anchor" id="autotoc_md13"></a>
New algorithm = new builder</h1>
<p>Just like we did in the previous tutorial, in order to create a new algorithm, even though built upon other algorithms, we need to create a new Algorithm::Builder. This is done as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>PowerLoop final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        <span class="comment">// Define our new algorithm here</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Up to this point, nothing new!</p>
<p>Note that calling <code>Algorithm::sanity_check</code> at this point will print the following warning message: </p><div class="fragment"><div class="line">WARNING(EMPTY_ALGORITHM), the algorithm instance is empty</div>
</div><!-- fragment --><p>Indeed, our algorithm, at this statge, is empty. No states have been added and no transitions have been defined.</p>
<p>In the next section, we will be "importing" or "inheriting" all the states from the ForLoop algorithm builder to our new builder. Let's see how it's done!</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Inheriting states and transitions</h1>
<p>Importing the states and transitions from another algorithm is done with the template method Algorithm::Builder::inherit&lt;T&gt;. See how it is easily used: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">    inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">}</div>
</div><!-- fragment --><p>At this stage, the sanity check should not complain anymore. Why? Simply because we have imported the ForLoop algorithm and because the ForLoop algorithm itself is well-defined. Thus, the obtained algorithm is well-defined. Note that you can also visualize it by using the Algorithm::plot function like we did in the previous tutorial. Doing so trivially yields the following image.</p>
<p><img src="https://raw.githubusercontent.com/hlefebvr/state_machine_cpp/main/src/images/my_algorithm_tx.png" alt="my_algorithm.png" class="inline"/></p>
<blockquote class="doxtable">
<p>IMPORTANT: note that to inherit from an algorithm, we did not use C++ inheritance. The use of C++ inheritance is heavily discourage regarding algorithm builders. </p>
</blockquote>
<p>Now let's apply our modifications!</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Applying modifications</h1>
<p>At this stage, we are totally free to write in our build function and are free to use the same functions as we did in the previous tutorial. For instance, we can use <code>states.create</code> to add new states or <code>transitions.create_if</code> to create a new conditional transition! Actually, we can totally re-route the whole algorithm and modify its flow!</p>
<p>For our purpose though, we only need to change the action associated to the transition LOOP_ITERATION -&gt; AFTER_LOOP_ITERATION since this is where the message is being printed. Note that we cannot use <code>transitions.create(LOOP_ITERATION, AFTER_LOOP_ITERATION, ...</code> anymore since a transition of this kind already exists. Though it is possible to remove a state or a transition and to re-create it in another form, it is more convenient to simply override it. To do so, simply use the function <code>transitions.override</code>. This is done as follows: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>PowerLoopAttributes {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> power;</div>
<div class="line">    <span class="keyword">explicit</span> PowerLoopAttributes(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_power) : power(t_power) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> handle_LOOP_ITERATION_with_power(Context&amp; context) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; power_loop_attribtues = context.get&lt;PowerLoopAttributes&gt;();</div>
<div class="line">    <span class="keyword">auto</span>&amp; for_loop_attributes = context.get&lt;ForLoopAttributes&gt;();</div>
<div class="line">    std::cout &lt;&lt; for_loop_attributes.iteration &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; std::pow(for_loop_attributes.iteration, power_loop_attributes.power) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PowerLoop final : <span class="keyword">public</span> Algorithm::Builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">build</a>(States&amp; states, Transitions&amp; transitions, Layers&amp; layers) {</div>
<div class="line">        </div>
<div class="line">        inherit&lt;ForLoop&gt;(states, transitions, layers);</div>
<div class="line">        </div>
<div class="line">        transitions.override(SHOW_COUNTER, INCREMENT_COUNTER, handle_LOOP_ITERATION_with_power);</div>
<div class="line">        </div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This code should be easy to understand. Briefly though, we create a struct containing the new attributes which were needed by our new algorithm. Note that we did not define "iteration" and "max_iteration" as those are part of the "ForLoop" algorithm from which we inherit. Then, we defined the new handler for the transition which comes from LOOP_ITERATION and goes to AFTER_LOOP_ITERATION. Finally, we used <code>transitions.override</code> to re-write the transition behaviour.</p>
<p>And that's it! You have successfully modified an algorithm and created a new one!</p>
<blockquote class="doxtable">
<p>Note that it is possible to override a conditional transition with <code>transitions.override_if</code> as well. You may also change the transition type. </p>
</blockquote>
<p>Now let's run our new algorithm! Once again, we have to create an algorithm instance, and to build the appropriate context. This is done as follows (in you <code>main</code> function): </p><div class="fragment"><div class="line"><span class="comment">// Building the algorithm</span></div>
<div class="line">Algorithm::Instance algorithm;</div>
<div class="line">Algorithm::build&lt;PowerLoop&gt;(algorithm);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sanity check</span></div>
<div class="line"><a class="code" href="namespacestate__machine__cpp_1_1Algorithm.html#aaad835bb89148ae5557bd849e5ec5c03">Algorithm::sanity_check</a>(algorithm);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creating the context</span></div>
<div class="line">ForLoopAttributes for_loop_attributes(3);</div>
<div class="line">PowerLoopAttributes power_loop_attributes(2);</div>
<div class="line">SimpleContext&lt;ForLoopAttributes, PowerLoopAttributes&gt; context(for_loop_attributes, power_loop_attributes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Running algorithm</span></div>
<div class="line"><a class="code" href="namespacestate__machine__cpp_1_1Algorithm_1_1Impl.html#a882597b42e60f4c46cee1580611249d6">Algorithm::run</a>(algorithm, context, INITIAL_STATE, FINAL_STATE);</div>
</div><!-- fragment --><p>Executing the code will now print out the following: </p><div class="fragment"><div class="line">0^2 = 0</div>
<div class="line">1^2 = 1</div>
<div class="line">2^2 = 4</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Advanced notions regarding inheritance</h1>
<p>In the next tutorial, we'll be diving into the concept of layers which solves the issue of inheriting multiple times from the same algorithm or simply inheriting from algorithms which use the same attribute class. For now, let us simply mention two advanced notions which are virtual transitions and final transitions.</p>
<p>Just like in C++, within <a class="el" href="namespacestate__machine__cpp.html">state_machine_cpp</a>, it is possible to leave transitions intentionally empty. The goal of such transitions are clearly to be defined later when the algorithm is being inherited to form another algorithm. Such transitions are created with the functions <code>transitions.create_virtual</code> and <code>transitions.create_if_virtual</code>. Visualizing an algorithm with <code>Algorithm::plot</code> will print out such transitions in blue and with the keyword "virtual". Moreover, calling <code>Algorithm::sanity_check</code> will report the presence of virtual transitions. Finally, running an algorithm in which some transitions are intentionally left empty will throw an exception to report what happened.</p>
<p>We've just seen how one can create a special transition which has to be defined later. Note that it is also possible, to the contrary, to declare some transitions as "final". Final transitions are transitions which cannot be overridden. Declaring a transition as final is done with the <code>transitions.declare_as_final</code> and by giving the state which starts the transition as argument.</p>
<p>That's it for now! In the next tutorial, we'll dive into the concept of layers! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_html_ac1e565dffdf5bbfe13afb2c9988e409f"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm.html#ac1e565dffdf5bbfe13afb2c9988e409f">state_machine_cpp::Algorithm::build</a></div><div class="ttdeci">void build(Algorithm::Instance &amp;t_destination)</div><div class="ttdef"><b>Definition:</b> <a href="build_8h_source.html#l00019">build.h:19</a></div></div>
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_1_1Impl_html_a882597b42e60f4c46cee1580611249d6"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm_1_1Impl.html#a882597b42e60f4c46cee1580611249d6">state_machine_cpp::Algorithm::Impl::run</a></div><div class="ttdeci">void run(Context &amp;t_context, const State::Id &amp;t_initial_state, const State::Id &amp;t_final_state, const std::function&lt; State::Instance(const State::Instance &amp;t_state, Context &amp;t_context)&gt; &amp;t_apply_transition)</div></div>
<div class="ttc" id="anamespacestate__machine__cpp_1_1Algorithm_html_aaad835bb89148ae5557bd849e5ec5c03"><div class="ttname"><a href="namespacestate__machine__cpp_1_1Algorithm.html#aaad835bb89148ae5557bd849e5ec5c03">state_machine_cpp::Algorithm::sanity_check</a></div><div class="ttdeci">bool sanity_check(const Algorithm::Instance &amp;t_algorithm)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
